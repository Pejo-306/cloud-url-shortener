# `cloudshortener`: Cloud-based URL Shortener

URL shortening service using AWS Lambda Functions as compute and Redis Cloud as
a backend database.

## Table of Contents

- [Background](#background)
- [System Design](#system-design)
- [Local Deployment](#local-deployment)
- [Cloud Deployment](#cloud-deployment)
- [Takeaways](#takeaways)
- [A NOTE on arm64 containers](#a-note-on-arm64-containers)
- [License](#license)

## Background

Before taking a position as a Software Engineer @ Redis, I wanted to practice system's design.
What other better way is there to get good at designing systems, other than building systems?

That's how this cloud URL shortening service began. A 3-week functioning MVP with
2 lambdas, a Redis and a barebones frontend has evolved into a complex system.

I am continuously working on this project to a) add new skills to my repertoire,
b) encounter and solve systems problems along the way. The better I get at solving
software systems problems in this project, the better I get at designing systems.

## System Design

This section details the intial system design + current high level system overview.

### Target

Design a URL shortening service

### Functional requirements

- App shortens a `long URL` into `short code`
- Accessing `short URL` will redirect with a `302` to `long URL`
- Redirect endpoint is *public*. User must sign up to access shortening endpoint.
- [BONUS] User can access analytics endpoint

### Non-functional requirements

- A user can create up to 20 short links per month (user quota)
- A short link can be accessed up to 10000 times per month (link hit quota)
- Redirect latency must be fast (preferably < 1s)
- Shorten latency is acceptable (up to 10s)
- Data retention: 1 year
- Daily Active Users (DAU): 100M
- Read:Write ratio - 100:1
- High availability => use fully managed compute & database services

### Back-of-the-napkin calculations

- \# of links / year = {Daily Active Users (DAU)} * 365 ~= 36 bil. links / year
- Assume each entry is about 500 bytes
- Database Capacity = {size of each entry} * {\# of links / year} = 500 bytes * 36 bil links = 18 tril. bytes = 18 TBs

### API design

`GET /{shortCode}` - Redirect to `long URL`
- Response code: `302`
- Response Headers: 

```json
{
  "Location": "http://example.com"
}
```

`POST /v1/shorten` - Shorten `long URL`
- Request body:

```json
{
  "target_url": "http://example.com"
}
```

- Response code: `200`
- Response body:

```json
{
  "short_url": "https://cloudshortener.com/GTY012",
  "shortcode": "GTY012"
}
```

### Data schema

For a backend data store we choose an in-memory Redis database (reasons below). Key schema:

- `links:counter` - global integer counter used to generate unique shortcodes
- `links:{shortcode}:url` - long URL for {shortcode}
- `links:{shortcode}:hits:{YYYY-MM}` - leftover link hits for month {YYYY-MM}
- `users:{user_id}:quota:{YYYY-MM}` - leftover link shortening quota for month {YYYY-MM}

### System diagram

**NOTE**: The system diagram is autogenerated by chatGPT and is only illustrative
of the entire system.

![Architecture Diagram](docs/assets/png/architecture-diagram.png)

- **API Gateway (Ingress)**: Routes requests and enforces authentication for protected endpoints
- **Redirect Service (Read Path)**: Stateless compute component that resolves shortcodes to long URLs and issues HTTP redirects
- **Shortening Service (Write Path)**: Stateless compute component that generates unique shortcodes and persists link mappings
- **Data Store**: Centralized data store (Redis Cloud) for shortcode-to-URL mappings, user quotas, and link access limits
- **Authentication Provider**: AWS-managed authentication (Amazon Cognito) for user identity management and token validation
- **Configuration and Secrets Management**: Runtime configuration and secrets (AWS AppConfig, Parameter Store, Secrets Manager)
- **Caching Layer**: High-speed cache (ElastiCache) for application configurations and frequently accessed data

### Deep dives

#### How many characters do we use to represent shortcodes?

A single character in a URL can be a lowercase letter, uppercase letter, or digit.
The English alphabet has 26 lowercase letters. That also means there's 26 uppercase letters. And the digits 0-9 are 10 in total.

Therefore, a single character can be one of `26 + 26 + 10 = 62` possible symbols.

At any given point in time, our database must be able to hold up to 36 bil. links.

Therefore, we need at minimum `ceil[log(base 62) of 36 bil.]` URL characters to
represent all possible links we can hold.

That's a **minimum of 6 characters**, which would mean we can store `62^6 ~= 56 bil.` links.

We choose to use **7 characters** with `62^7 ~= 3.5 tril.` combinations because we might 
use a hash or hash-like function when generating shorcodes. So we want to minimize 
the possibility of collissions. Also, if we choose to expand our retention period,
we can now store up to 97 years of links (`3.5 tril / 36 bil.`) in our data store.

#### What function do we use to generate shortcodes?

Multiple options are available and were evaluated:

a) Use a standard hash function

Hash functions may be fast and convinient, but they introduce the possibility of
collisions. Since we have overcompensated with `3.5 tril.` possible shorcode 
combinations, we'd like to avoid collisions altogether.

b) UUID

Relies on randomness but the generated value is too long. It would be over-engineering
the solution.

c) Sequence number (chosen solution)

We save a global counter and increment it every single time we generate a new
link. Then, we just use this counter to represent the link.

This method ensures 1:1 uniqueness so we don't have to deal with collisions.

On the other hand, using `0000032` or `000A11B` introduces a possible security risk
of revealing our internal application workings. That's why we instead map
the counter value to a salted hash, then digest that hash into 7 characters:

`counter -> divmod(salted hash + hash, 62^7) -> "".join(ALPHABET[for character in 7 characters])`

So we get a globally unique, non-collision, 7-digit shortcode which can be generated
fast with a FAST hashing algorithm.

What happens once the `counter` value surpasses `62^7` - Wouldn't tha cause collisions?

Technically yes. But since we only need to hold a very small `36 bil` subset of
the space `62^7` in our database at any given time, those initial shortcodes with
counter values from `0` to `36 bil` would long have been freed up (about 97 years ago).
So we can safely reuse them. The `counter` "wraps" back around the available space.

#### How do we retain links for up to a year in our database?

Since we're using Redis as our backend data store, we can set the TTL on
`links:{shortcode}:url` keys to 1 year and allow the database to evict it.

#### How do we enforce user quotas?

We create a key `users:{user_id}:quota:{YYYY-MM}` with an integer value of 0
and TTL of 1 month. The value of `{YYYY-MM}` is the current year and month, e.g.
`2025-12`.

Once we trigger `ShortenUrlFunction`, we first retrieve and check if the value is
equal to 20. If yes, the function responds with a `429` response, limitting the user
from creating more links for the month.

Each time `ShortenUrlFunction` creates a link, the value is incremented by 1 via:

```
INCR users:{user_id}:quota:{YYYY-MM}
```

Once next month rolls around, the link creating quota is "reset" since we are now
using the next `{YYYY-MM}` calendar month, e.g. `2026-01`. So the process 
above repeats. The old calendar month's key `2025-12` expires.

#### How do we enforce link hit quotas?

We create a key `links:{shortcode}:hits:{YYYY-MM}` with an integer value of 10000
and a TTL of 1 month. The value of `{YYYY-MM}` is the current year and month, e.g.
`2025-12`.

Once we trigger `RedirectUrlFunction`, we first retrieve and check if the value is
less than 0. If yes, the function responds with a `429` response, limitting access
to this short link.

Each time `RedirectUrlFunction` redirects, it decrements the value by 1 via:

```
DECR links:{shortcode}:hits:{YYYY-MM}
```

Once next month rolls around, the link hits quota is "reset" since we are now
using the next `{YYYY-MM}` calendar month, e.g. `2026-01`. So the process 
above repeats. The old calendar month's key `2025-12` expires.

## Local Deployment

In local deployment, this project uses SAM and Docker to run AWS Lambda Functions in
docker containers. There's also a [docker compose](local/compose.yaml) which
creates:
- a Redis database
- [Redis Insight](https://redis.io/insight/)
- Localstack (store AWS parameters and secrets locally)
- AWS AppConfig Agent (get AppConfig deployments locally)

**NOTE**: Localstack is not used in fully local deployment. It's needed for hybrid
deployment (see below).

All commands below assume you run from the **repository root**. Use the root
[Makefile](Makefile) (`make help` for targets).

### Prerequisites

- [Python](https://www.python.org/) 3.13+
- [uv](https://docs.astral.sh/uv/) (Python package manager)
- [Node.js](https://nodejs.org/) (for frontend)
- [Docker](https://www.docker.com/) v 29.1+ and [Docker Compose](https://docs.docker.com/compose/) v2.40+
- [SAM](https://aws.amazon.com/serverless/sam/)

### Setup

1. Install dependencies:

```bash
make install
```

2. Start the Docker Compose stack:

```bash
make up
```

**NOTE**: The Docker Compose stack uses the following ports on your machine:
- **Redis** on port **6379**
- **Redis Insight** on port **5540**
- **Localstack** on ports **4566** and **4571**
- **AppConfig Agent** on port **2772**

If your machine is already using any of the listed ports, override them, e.g.
`make up REDIS_PORT=7000`. See `make help` for configurable variables.

3. Build the app (backend, frontend, and infra):

```bash
make build
```

4. Start the local SAM API and Vite dev server:

```bash
make dev
```

Then, you can access the following two endpoints:
- POST [localhost:3000/v1/shorten](http://localhost:3000/v1/shorten)
- GET  [localhost:3000/{shortcode}](http://localhost:3000/Gh71TC0)

You can use a tool like [curl](https://curl.se/) or [Postman](https://www.postman.com/) 
to interact with the API. Check [events](events/) directory for sample JSON 
events you can send to both lambdas.

### Invoke functions directly

Invoke `ShortenUrlFunction`:

```bash
make invoke FUNCTION=ShortenUrlFunction EVENT_FILE=events/shorten_url/event.json
```

Invoke `RedirectUrlFunction`:

```bash
make invoke FUNCTION=RedirectUrlFunction EVENT_FILE=events/redirect_url/event.json
```

## Cloud Deployment

In cloud deployment, an AWS CloudFormation stack is used to create and manage
all AWS resources.

All commands below assume you run from the **repository root**. Use the root
[Makefile](Makefile) (`make help` for targets).

### Prerequisites

- [AWS Free Tier account](https://aws.amazon.com/free/) (paid one also works)
- [uv](https://docs.astral.sh/uv/) (Python package manager)
- [act](https://github.com/nektos/act) and/or [GitHub](https://github.com/) repo with [GitHub actions](https://github.com/features/actions)

### Setup

1. Deploy OIDC stack (allows GitHub Actions and `act` to deploy to AWS):

```bash
make bootstrap
```

To use an existing OIDC provider:

```bash
make bootstrap EXISTING_OIDC_PROVIDER_ARN=arn:aws:iam::123456789012:oidc-provider/token.actions.githubusercontent.com
```

Override `GITHUB_ORG` and `REPO_NAME` if needed (see `make -C infra/bootstrap help`).

2. Create dev environment configuration files by editing and renaming the files:
- [config/shorten_url/dev.example.yaml](config/shorten_url/dev.example.yaml) → `config/shorten_url/dev.yaml`
- [config/redirect_url/dev.example.yaml](config/redirect_url/dev.example.yaml) → `config/redirect_url/dev.yaml`

```bash
cp config/shorten_url/dev.example.yaml config/shorten_url/dev.yaml
cp config/redirect_url/dev.example.yaml config/redirect_url/dev.yaml
# Edit both files with your config values
```

**NOTE:** dev.yaml / staging.yaml / prod.yaml are in *.gitignore*, so your secrets won't be committed.

3. Deploy the orchestrator stack. This runs pre-deploy (seed SSM, secrets, ElastiCache credentials), deploys the SAM stack, then post-deploy (seed ElastiCache SSM params, sync frontend):

```bash
export ELASTICACHE_PASSWORD='<your ElastiCache password>'
make deploy
```

**NOTE:** The ElastiCache password must be 32–128 printable ASCII characters, no spaces, no `/*`, `"`, `@`, with at least one uppercase letter and one digit. Example: `bP7f2Qk9LxN4Rz8TgH3mVw6YcJ5pK1sD`.

Override `APP_NAME`, `APP_ENV`, `AWS_REGION`, `AWS_PROFILE` as needed (e.g. `make deploy APP_ENV=staging AWS_PROFILE=prod`).

4. Create frontend configuration (after first deploy, to get stack outputs):

```bash
cp frontend/config/dev/example.app.config.json frontend/config/dev/app.config.json
```

Edit `app.config.json` and fill in values from the stack outputs:
- `backend.host`: `ApiUrl` output
- `aws.cognito.userPoolId`: `UserPoolId` output
- `aws.cognito.clientId`: `UserPoolClientId` output

Retrieve outputs:

```bash
aws cloudformation describe-stacks \
  --stack-name cloudshortener-dev \
  --query "Stacks[0].Outputs" \
  --output table \
  --profile <your AWS profile>
```

5. Sync frontend to S3 (if you updated `app.config.json` after deploy):

```bash
make -C infra sync-frontend APP_NAME=cloudshortener APP_ENV=dev
```

Alternatively, run `make deploy` again; post-deploy includes frontend sync.

### Access the app

Visit the `FrontendUrl` in your browser:

```bash
aws cloudformation describe-stacks \
  --stack-name cloudshortener-dev \
  --query "Stacks[0].Outputs[?OutputKey=='FrontendUrl'].OutputValue" \
  --output text \
  --profile <your AWS profile>
```

### Destroy the stack

```bash
make destroy
```

Happy shortening!

## A NOTE on arm64 containers

What happens if you get some error related to unsupported `arm64` architecture?

In [infra/stacks/backend/template.yaml](infra/stacks/backend/template.yaml) you might notice that the Lambda runtimes are
in `arm64` containers. It's because I'm developing on a Mac which is why native
`x86_64` didn't work for me well.

If you are developing on `x86_64` architecture (e.g. a Linux distribution), you
can switch out the architecture inside [infra/stacks/backend/template.yaml](infra/stacks/backend/template.yaml):

```yaml
Globals:
  Function:
    Timeout: 30
    Tracing: Active
    LoggingConfig:
      LogFormat: JSON
    Runtime: python3.13
    Architectures:
      - x86_64  # <-- switch this from `arm64` to `x86_64`
```

## Takeaways

#### 1) Why monoliths exist

This app started out as two barebones lambdas and a simple Redis database. Now
it's grown to such a big infrastructure and codebase for what it's doing, even I -
the creator - find it hard to navigate my own codebase.

It's because the initial goal was to get this app out FAST - get a working MVP
demo in 3 weeks. Not much thought was put into the maintainability and growth
beyond the initial system design.

It's both a success and failure - I got the MVP up and running in 3 weeks, but
not without making long-term maintainability tradeoffs.

That's why this project grew into one big monolith. It's also why I believe being
good at system's design is all about - having the ability to forsee and solve
downstream problems preemptively AND still starting fast. Having the sense to
weight in technical and non-technical tradeoffs both now and in the long-term.

PS: I should build a microservices app next.

#### 2) Building MVPs is easy. Building for scale is hard.

It's easy to make a small project work for myself. There's only one person I'm
serving - me.

Building a project which serves a group at scale is where it gets hard. Even
thought my system design has accouted for scale, the actual app (in it's current
state) can't handle the large scale it is designed for.

#### 3) Flat Pythonic code is just great

There's a self-adopted convention I follow with my codebase which keeps my code
structure relatively flat and easy to navigate for myself.

Unfortunately, I'm the only one who knows this self-taught convention.

It would be much better if I enforced a design decision, a standard on my
codebase before starting to code.

Enforced standards are predictable. Conventions are not very predictable.

## License

This project is distributed under the [MIT license](LICENSE).
